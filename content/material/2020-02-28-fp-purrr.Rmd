---
title: "Efficient coding when iterating"
author:
  - "Florian PrivÃ©"
  - "Luke W. Johnston"
date: "2020-02-28"
description: >
  Do you repeat yourself often when writing code? Do you make use of loops? Come
  to this session to learn how to write R code more efficiently and for some best
  practices to follow.
categories:
  - Beginner-Intermediate
  - R
  - Code-along
tags:
  - purrr
  - functional programming
  - iterations
---

```{r setup, echo=FALSE}
source(here::here("R/utils-for-content.R"))
```

# Session details

> Source: These materials are based on the book [*Functional Programming*](https://dcl-prog.stanford.edu/).

## Preparation

Please install these packages:

```{r pkg-install, eval=FALSE}
install.packages(tidyverse)
```

## Objectives

By the end of this session, you will be able to:

- Efficiently iterate over one or more vectors or lists by applying the `map`
family of functions from the purrr package.

**Resources** for continuing learning and help are available on
the [More Info](/more-info/#resources) page.

# Writing R code that iterates more efficiently with package purrr

While in other programming languages, 
iterating over many items in a vector or list requires using a "for loop".
However, R has many powerful tools that simplify this iteration with the
use of "mapping" functions.
"Mapping" involves taking a vector 
(a sequence of numbers, characters, or other data types) 
and applying a function to each of the item in the vector at the same time.
This can greatly simplify code 
and allows the user to be quite expressive in translating analysis ideas to code.

While base R has some useful functions like `apply()`,
the purrr package bundles these "mapping" functionality into a consistent 
and fairly intuitive interface (not to mention excellent documentation on
their [website](https://purrr.tidyverse.org/)). 
In this session we'll cover some of purrr's functions.

## First steps: Project setup

Like most teaching sessions, we'll first start with creating an R project.
R projects are incredibly useful tools and we strongly recommend you use them.
Create a new project, name it "iterating-with-purrr".
Once the R project has been opened, create two new files and save them as
`code-along.R` and `exercises.R`.

Open up the `code-along.R` file and add these to the top of the file:

```{r load-packages-see-data, include=FALSE, echo=TRUE}
# Import the packages we'll use
library(tidyverse)
```

## Basic map functions

We're going to learn about the `map*` family from package purrr.

### Iterating is like an assembly line

Often you many need to apply the same function to each element of a list or vector. 
Let's use an example with a list of vectors (with randomly generated data):

```{r create-example-list}
set.seed(1)
samples <- list(
  samp1 = runif(5),
  samp2 = rnorm(10),
  samp3 = rgamma(7, 1)
)
```

What if we want to find out the number of values in each samples. 
Using `length()` may come to mind, but `length()` only outputs a single value:

```{r length-samples}
length(samples)
```

`length(samples)` returns the number of list items in `samples`, 
but doesn't find the length of each item in the list which is what we want to know.
So instead, we want to apply `length()` to each vector in `samples`. 
We could do this repeatedly on each individual item:

```{r length-all-list-items}
length(samples$samp1)
length(samples$samp2)
length(samples$samp3)
```

But this approach is quite tedious, too manual 
(any change in the names of the list requires you to change the code here),
and prone to human error.
The problem gets worse when you have more items in the list.
Thankfully, we can use purrr's functions to do this for us.

### The map functions

The `map()` function from purrr is the most general of the functions, 
so let's cover it first.
`map()`, like all the map functions, is fairly simple in what you give it:
It takes a list or vector and a function as arguments.

```{r fig-map-basics, echo=FALSE, fig.cap="Visual of basic usage of map arguments. Image from [purrr basics](https://dcl-prog.stanford.edu/purrr-basics.html) section."}
knitr::include_graphics("https://raw.githubusercontent.com/dcl-docs/prog/master/images/map-step-1.png") 
```

`map()` applies the given function to each elemtn of the input list or vector.

```{r fig-map-to-each, echo=FALSE, fig.cap="Visual of function applying to each item when using map. Image from [purrr basics](https://dcl-prog.stanford.edu/purrr-basics.html) section."}
knitr::include_graphics("https://raw.githubusercontent.com/dcl-docs/prog/master/images/map-step-2.png") 
```

After the function is applied to each element, 
map outputs the results based on the number of elements in the list or vector.

```{r fig-map-output-pre, echo=FALSE, fig.cap="Visual of output of the function from each item. Image from [purrr basics](https://dcl-prog.stanford.edu/purrr-basics.html) section."}
knitr::include_graphics("https://raw.githubusercontent.com/dcl-docs/prog/master/images/map.png") 
```

Finally, `map()` puts these output items into a list.

```{r fig-map-output-final, echo=FALSE, fig.cap="Visual of final output of using map. Image from [purrr basics](https://dcl-prog.stanford.edu/purrr-basics.html) section."}
knitr::include_graphics("https://raw.githubusercontent.com/dcl-docs/prog/master/images/map-output.png")
```

Let's see an example of using `map()`:

```{r using-map}
map(samples, length)
```

Notice a small difference here. 
We use `length` instead of `length()` to indicate the function to use. 
The reason is that R evaluates `length()` first before being given to `map()`
because the added `()` tell R it needs to do an action,
which isn't want we want. 
We want `map()` to take the `length` function object 
and use the function later on each item of the list or vector given.

The nice thing about purrr functions is that they are *consistent*.
`map()` returns a list:

```{r}
typeof(map(samples, length))
```

But maybe we want something different. 
While, by adding an ending to `map`, we can easily output something different.
purrr also has these other variations:

* `map_int()` outputs an integer vector.
* `map_dbl()` outputs a double vector.
* `map_chr()` outputs a character vector.
* `map_lgl()` outputs a logical vector.

So, since `length()` returns integers, 
let's use use `map_int()` to create an integer vector instead of a list.

```{r}
map_int(samples, length)
typeof(map_int(samples, length))
```

Here is a visual demonstration:

```{r fig-mapint-basic, echo=FALSE, fig.cap="Visual of using `map_int()`. Image from [purrr basics](https://dcl-prog.stanford.edu/purrr-basics.html) section."}
knitr::include_graphics("https://raw.githubusercontent.com/dcl-docs/prog/master/images/map-int.png")
```

Which outputs a vector instead of a list:

```{r fig-mapint-output, echo=FALSE, fig.cap="Visual of output of `map_int()`. Image from [purrr basics](https://dcl-prog.stanford.edu/purrr-basics.html) section."}
knitr::include_graphics("https://raw.githubusercontent.com/dcl-docs/prog/master/images/map-int-output.png")
```

The other versions of `map()` produce double (numeric), character, 
and logical vectors just as `map_int()` does.

Let's try using another function, like `median()`:

```{r}
map(samples, median)
```

Since the output is a numeric type (a double), we could use `map_dbl()`:

```{r}
map_dbl(samples, median)
```

#### Exercise 

Time: 10 min

```{r}

```


Use `map_chr()` to create a character vector when using a function that produces characters, and `map_lgl()` to create logical vectors.

### Giving arguments to the function in map


For example, `sort()` arranges in increasing order.

```{r}
map(samples, sort)
```

To sort in decreasing order, we have to specify `decreasing = TRUE` inside of `sort()`. Outside of a map function, we would just put `decreasing = TRUE` into the function call.

```{r}
sort(samples$samp1, decreasing = TRUE)
```

Inside a map function, you put function arguments directly after the function name (passed as `...`).

```{r}
map(samples, sort, decreasing = TRUE)
```

You can add as many arguments as you like, and `map()` will automatically supply them to the function.

```{r echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/dcl-docs/prog/master/images/map-extra-arg.png")
```

For example, the following code uses two additional arguments to find the 95th quantile for each sample, excluding missing values. 

```{r}
map_dbl(samples, quantile, probs = 0.95, na.rm = TRUE)
```

### Anonymous functions

So far in the reading, we've only given map functions **named** functions. Recall that named functions have a name which you can use to call the function. 

Say we want to convert the moon radii from kilometers to miles. Here's a named function that turns kilometers into miles.

```{r}
km_to_miles <- function(x) {
  x * 0.62
}
```

Anytime we want to convert kilometers to miles, we can now call `km_to_miles()`.

```{r}
km_to_miles(22)
```

Now, we can use `km_to_miles()` and `map()` to convert all moon radii to miles. We have to use `map()` because `km_to_miles()` will return a vector for each sample.

```{r}
map(samples, km_to_miles)
```

If we're not going to use `km_to_miles()` again, we don't need to make a named function. It will be less work and more succinct to just create an anonymous function inside `map()`. Recall that anonymous functions are just functions without names, and the full syntax  looks like this:

```{r}
function(x) x * 0.62
```

We can copy this anonymous function directly into `map()`.

```{r}
map(samples, function(x) x * 0.62)
```

The full syntax for anonymous functions is clunky, so purrr provides a shortcut. Here's what the code looks like if we use the shortcut:

```{r}
map(samples, ~ . * 0.62)
```

The `~` tells `map()` that an anonymous function is coming. The `.` refers to the function argument, taking the place of `x` from the full anonymous function syntax. 

### Tibbles

All the examples so far have used the map function on `samples`, a list of vectors, but the map functions work on any type of vector or list, including tibbles. 

Tibbles are lists of vectors. Notice that when you create a tibble with `tibble()`, you create a vector for each column.

```{r}
y <- tibble(
  col_1 = c(1, 2, 3),
  col_2 = c(100, 200, 300),
  col_3 = c(0.1, 0.2, 0.3)
)
y
```

Because the elements of a tibble are the vector columns, map functions act on the tibble columns, not the tibble rows.

```{r}
map_dbl(y, median)
```

#### Exercise

1. Why does `map()` also work on tibbles?

2. Reimplement `map()` into `my_map()` using a for-loop to understand how it works internally.

## map functions that output tibbles

In this reading, you'll learn about two more map variants, `map_dfr()` and `map_dfc()`. Then, you'll learn about `walk()`, as well as some useful purrr functions that work with functions that return either `TRUE` or `FALSE`.

Instead of creating an atomic vector or list, the map variants `map_dfr()` and `map_dfc()` create a tibble. 

With these map functions, the assembly line worker creates a tibble for each input element, and the output conveyor belt ends up with a collection of tibbles. 

```{r echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/dcl-docs/prog/master/images/map_df.png")
```

The worker then combines all the small tibbles into a single, larger tibble. There are multiple ways to combine smaller tibbles into a larger tibble. `map_dfr()` (*r* for *rows*) stacks the smaller tibbles on top of each other. 

```{r echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/dcl-docs/prog/master/images/map_dfr.png")
```

`map_dfc()` (*c* for *columns*) stacks them side-by-side.

```{r echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/dcl-docs/prog/master/images/map_dfc.png")
```

There are `_dfr` and `_dfc` variants of `pmap()` and `map2()` as well. In the following sections, we'll cover `map_dfr()` in more detail.

### `_dfr`

`map_dfr()` is useful when reading in data from multiple files. The following code reads in several very simple csv files, each of which contains the name of a different dinosaur genus.

```{r, message=FALSE}
url_folder <- "https://raw.githubusercontent.com/dcl-docs/prog/master/data/purrr-extras"
read_csv(paste0(url_folder, "/file_001.csv"))
read_csv(paste0(url_folder, "/file_002.csv"))
read_csv(paste0(url_folder, "/file_003.csv"))
```

`read_csv()` produces a tibble, and so we can use `map_dfr()` to map over all three file names and bind the resulting individual tibbles into a single tibble.

```{r, message=FALSE}
files <- str_glue("{url_folder}/file_00{1:3}.csv")
files
map_dfr(files, read_csv)
```

The result is a tibble with three rows and two columns, because `map_dfr()` aligns the columns of the individual tibbles by name. 

The individual tibbles can have different numbers of rows or columns. `map_dfr()` just creates a column for each unique column name. If some of the individual tibbles lack a column that others have, `map_dfr()` fills in with `NA` values.

```{r, message=FALSE}
map_dfr(str_glue("{url_folder}/file_00{1:4}.csv"), read_csv)
```
### Using two vectors or lists as input

In the previous purrr units, you learned how to use the `map()` functions to iterate over a single vector and apply a function to each element. `purrr` also contains functions that can iterate over several vectors at once, supplying the first elements of each vector to a given function, then the second, then the third, etc.

Below, you'll learn about the `map2()` functions, which can handle two input vectors.

The `map2()` functions are very similar to the `map()` functions you learned about previously, but they take two input vectors instead of one.

```{r echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/dcl-docs/prog/master/images/map2.png")
```

For example, here are two vectors, `x` and `y`.

```{r}
x <- c(1, 2, 4)
y <- c(6, 5, 3.5)
```

We can use a `map2()` variant to iterate along both vectors at once. The following code creates a new vector whose first element is the minimum of `x[1]` and `y[1]`, second element is the minimum of `x[2]` and `y[2]`, and third element is the minimum of `x[3]` and `y[3]`.

```{r}
map2_dbl(x, y, min)
```

For the `map2()` functions to work, the two vectors need to have the same length.

```{r, error=TRUE}
x2 <- c(1, 2, 4)
y2 <- c(6, 5)
map2_dbl(x2, y2, min)
```

Inside anonymous functions in the `map()` functions, you refer to each element of the input vector as `.` . In the `map2()` functions, you refer to elements of the first vector as `.x` and elements of the second as `.y` .

```{r}
map2_dbl(x, y, ~ min(.x, .y))
```


## Additional comments

To easily implement parallel processing for when you have very complex or computationally long analysis,
check out the [furrr package](https://github.com/DavisVaughan/furrr).
